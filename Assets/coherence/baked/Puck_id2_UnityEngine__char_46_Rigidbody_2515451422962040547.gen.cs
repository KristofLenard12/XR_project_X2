// Copyright (c) coherence ApS.
// For all coherence generated code, the coherence SDK license terms apply. See the license file in the coherence Package root folder for more information.

// <auto-generated>
// Generated file. DO NOT EDIT!
// </auto-generated>
namespace Coherence.Generated
{
	using Coherence.ProtocolDef;
	using Coherence.Serializer;
	using Coherence.SimulationFrame;
	using Coherence.Entity;
	using Coherence.Utils;
	using Coherence.Brook;
	using Coherence.Toolkit;
	using UnityEngine;

	public struct Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547 : ICoherenceComponentData
	{
		public Vector3 velocity;
		public Vector3 angularVelocity;
		public float drag;
		public float angularDrag;
		public float mass;
		public bool useGravity;
		public float maxDepenetrationVelocity;
		public bool isKinematic;
		public bool freezeRotation;
		public Vector3 centerOfMass;
		public Quaternion inertiaTensorRotation;
		public Vector3 inertiaTensor;
		public bool detectCollisions;
		public Vector3 position;
		public Quaternion rotation;
		public int solverIterations;
		public float sleepThreshold;
		public float maxAngularVelocity;
		public int solverVelocityIterations;
		public int solverIterationCount;
		public int solverVelocityIterationCount;

		public override string ToString()
		{
			return $"Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547(velocity: {velocity}, angularVelocity: {angularVelocity}, drag: {drag}, angularDrag: {angularDrag}, mass: {mass}, useGravity: {useGravity}, maxDepenetrationVelocity: {maxDepenetrationVelocity}, isKinematic: {isKinematic}, freezeRotation: {freezeRotation}, centerOfMass: {centerOfMass}, inertiaTensorRotation: {inertiaTensorRotation}, inertiaTensor: {inertiaTensor}, detectCollisions: {detectCollisions}, position: {position}, rotation: {rotation}, solverIterations: {solverIterations}, sleepThreshold: {sleepThreshold}, maxAngularVelocity: {maxAngularVelocity}, solverVelocityIterations: {solverVelocityIterations}, solverIterationCount: {solverIterationCount}, solverVelocityIterationCount: {solverVelocityIterationCount})";
		}

		public uint GetComponentType() => Definition.InternalPuck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547;

		public const int order = 0;

		public int GetComponentOrder() => order;

		public AbsoluteSimulationFrame Frame;

		private static readonly float _velocity_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _angularVelocity_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _drag_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _angularDrag_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _mass_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _maxDepenetrationVelocity_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _centerOfMass_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _inertiaTensorRotation_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _inertiaTensor_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _position_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _rotation_Epsilon = 2.3283064365386963e-10f;
		private static readonly int _solverIterations_Min = -2147483648;
		private static readonly int _solverIterations_Max = 2147483647;
		private static readonly float _sleepThreshold_Epsilon = 2.3283064365386963e-10f;
		private static readonly float _maxAngularVelocity_Epsilon = 2.3283064365386963e-10f;
		private static readonly int _solverVelocityIterations_Min = -2147483648;
		private static readonly int _solverVelocityIterations_Max = 2147483647;
		private static readonly int _solverIterationCount_Min = -2147483648;
		private static readonly int _solverIterationCount_Max = 2147483647;
		private static readonly int _solverVelocityIterationCount_Min = -2147483648;
		private static readonly int _solverVelocityIterationCount_Max = 2147483647;

		public void SetSimulationFrame(AbsoluteSimulationFrame frame)
		{
			Frame = frame;
		}

		public AbsoluteSimulationFrame GetSimulationFrame() => Frame;

		public ICoherenceComponentData MergeWith(ICoherenceComponentData data, uint mask)
		{
			var other = (Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547)data;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				velocity = other.velocity;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				angularVelocity = other.angularVelocity;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				drag = other.drag;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				angularDrag = other.angularDrag;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				mass = other.mass;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				useGravity = other.useGravity;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				maxDepenetrationVelocity = other.maxDepenetrationVelocity;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				isKinematic = other.isKinematic;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				freezeRotation = other.freezeRotation;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				centerOfMass = other.centerOfMass;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				inertiaTensorRotation = other.inertiaTensorRotation;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				inertiaTensor = other.inertiaTensor;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				detectCollisions = other.detectCollisions;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				position = other.position;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				rotation = other.rotation;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				solverIterations = other.solverIterations;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				sleepThreshold = other.sleepThreshold;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				maxAngularVelocity = other.maxAngularVelocity;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				solverVelocityIterations = other.solverVelocityIterations;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				solverIterationCount = other.solverIterationCount;
			}
			mask >>= 1;
			if ((mask & 0x01) != 0)
			{
				Frame = other.Frame;
				solverVelocityIterationCount = other.solverVelocityIterationCount;
			}
			mask >>= 1;
			return this;
		}

		public uint DiffWith(ICoherenceComponentData data)
		{
			uint mask = 0;
			var newData = (Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547)data;

			if (velocity.DiffersFrom(newData.velocity, _velocity_Epsilon)) {
				mask |= 0b00000000000000000000000000000001;
			}
			if (angularVelocity.DiffersFrom(newData.angularVelocity, _angularVelocity_Epsilon)) {
				mask |= 0b00000000000000000000000000000010;
			}
			if (drag.DiffersFrom(newData.drag, _drag_Epsilon)) {
				mask |= 0b00000000000000000000000000000100;
			}
			if (angularDrag.DiffersFrom(newData.angularDrag, _angularDrag_Epsilon)) {
				mask |= 0b00000000000000000000000000001000;
			}
			if (mass.DiffersFrom(newData.mass, _mass_Epsilon)) {
				mask |= 0b00000000000000000000000000010000;
			}
			if (useGravity != newData.useGravity) {
				mask |= 0b00000000000000000000000000100000;
			}
			if (maxDepenetrationVelocity.DiffersFrom(newData.maxDepenetrationVelocity, _maxDepenetrationVelocity_Epsilon)) {
				mask |= 0b00000000000000000000000001000000;
			}
			if (isKinematic != newData.isKinematic) {
				mask |= 0b00000000000000000000000010000000;
			}
			if (freezeRotation != newData.freezeRotation) {
				mask |= 0b00000000000000000000000100000000;
			}
			if (centerOfMass.DiffersFrom(newData.centerOfMass, _centerOfMass_Epsilon)) {
				mask |= 0b00000000000000000000001000000000;
			}
			if (inertiaTensorRotation.DiffersFrom(newData.inertiaTensorRotation, _inertiaTensorRotation_Epsilon)) {
				mask |= 0b00000000000000000000010000000000;
			}
			if (inertiaTensor.DiffersFrom(newData.inertiaTensor, _inertiaTensor_Epsilon)) {
				mask |= 0b00000000000000000000100000000000;
			}
			if (detectCollisions != newData.detectCollisions) {
				mask |= 0b00000000000000000001000000000000;
			}
			if (position.DiffersFrom(newData.position, _position_Epsilon)) {
				mask |= 0b00000000000000000010000000000000;
			}
			if (rotation.DiffersFrom(newData.rotation, _rotation_Epsilon)) {
				mask |= 0b00000000000000000100000000000000;
			}
			if (solverIterations != newData.solverIterations) {
				mask |= 0b00000000000000001000000000000000;
			}
			if (sleepThreshold.DiffersFrom(newData.sleepThreshold, _sleepThreshold_Epsilon)) {
				mask |= 0b00000000000000010000000000000000;
			}
			if (maxAngularVelocity.DiffersFrom(newData.maxAngularVelocity, _maxAngularVelocity_Epsilon)) {
				mask |= 0b00000000000000100000000000000000;
			}
			if (solverVelocityIterations != newData.solverVelocityIterations) {
				mask |= 0b00000000000001000000000000000000;
			}
			if (solverIterationCount != newData.solverIterationCount) {
				mask |= 0b00000000000010000000000000000000;
			}
			if (solverVelocityIterationCount != newData.solverVelocityIterationCount) {
				mask |= 0b00000000000100000000000000000000;
			}

			return mask;
		}

		public static void Serialize(Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547 data, uint mask, IOutProtocolBitStream bitStream)
		{
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteVector3((data.velocity.ToCoreVector3()), FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteVector3((data.angularVelocity.ToCoreVector3()), FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteFloat(data.drag, FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteFloat(data.angularDrag, FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteFloat(data.mass, FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteBool(data.useGravity);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteFloat(data.maxDepenetrationVelocity, FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteBool(data.isKinematic);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteBool(data.freezeRotation);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteVector3((data.centerOfMass.ToCoreVector3()), FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteQuaternion((data.inertiaTensorRotation.ToCoreQuaternion()), 32);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteVector3((data.inertiaTensor.ToCoreVector3()), FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteBool(data.detectCollisions);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteVector3((data.position.ToCoreVector3()), FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteQuaternion((data.rotation.ToCoreQuaternion()), 32);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				Coherence.Utils.Bounds.Check(data.solverIterations, _solverIterations_Min, _solverIterations_Max, "Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547.solverIterations");
				data.solverIterations = Coherence.Utils.Bounds.Clamp(data.solverIterations, _solverIterations_Min, _solverIterations_Max);
				bitStream.WriteIntegerRange(data.solverIterations, 32, -2147483648);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteFloat(data.sleepThreshold, FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				bitStream.WriteFloat(data.maxAngularVelocity, FloatMeta.NoCompression());
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				Coherence.Utils.Bounds.Check(data.solverVelocityIterations, _solverVelocityIterations_Min, _solverVelocityIterations_Max, "Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547.solverVelocityIterations");
				data.solverVelocityIterations = Coherence.Utils.Bounds.Clamp(data.solverVelocityIterations, _solverVelocityIterations_Min, _solverVelocityIterations_Max);
				bitStream.WriteIntegerRange(data.solverVelocityIterations, 32, -2147483648);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				Coherence.Utils.Bounds.Check(data.solverIterationCount, _solverIterationCount_Min, _solverIterationCount_Max, "Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547.solverIterationCount");
				data.solverIterationCount = Coherence.Utils.Bounds.Clamp(data.solverIterationCount, _solverIterationCount_Min, _solverIterationCount_Max);
				bitStream.WriteIntegerRange(data.solverIterationCount, 32, -2147483648);
			}
			mask >>= 1;
			if (bitStream.WriteMask((mask & 0x01) != 0))
			{
				Coherence.Utils.Bounds.Check(data.solverVelocityIterationCount, _solverVelocityIterationCount_Min, _solverVelocityIterationCount_Max, "Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547.solverVelocityIterationCount");
				data.solverVelocityIterationCount = Coherence.Utils.Bounds.Clamp(data.solverVelocityIterationCount, _solverVelocityIterationCount_Min, _solverVelocityIterationCount_Max);
				bitStream.WriteIntegerRange(data.solverVelocityIterationCount, 32, -2147483648);
			}
			mask >>= 1;
		}

		public static (Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547, uint, uint?) Deserialize(InProtocolBitStream bitStream)
		{
			var mask = (uint)0;
			var val = new Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547();
			if (bitStream.ReadMask())
			{
				val.velocity = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000000000000001;
			}
			if (bitStream.ReadMask())
			{
				val.angularVelocity = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000000000000010;
			}
			if (bitStream.ReadMask())
			{
				val.drag = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000000000100;
			}
			if (bitStream.ReadMask())
			{
				val.angularDrag = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000000001000;
			}
			if (bitStream.ReadMask())
			{
				val.mass = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000000010000;
			}
			if (bitStream.ReadMask())
			{
				val.useGravity = bitStream.ReadBool();
				mask |= 0b00000000000000000000000000100000;
			}
			if (bitStream.ReadMask())
			{
				val.maxDepenetrationVelocity = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000001000000;
			}
			if (bitStream.ReadMask())
			{
				val.isKinematic = bitStream.ReadBool();
				mask |= 0b00000000000000000000000010000000;
			}
			if (bitStream.ReadMask())
			{
				val.freezeRotation = bitStream.ReadBool();
				mask |= 0b00000000000000000000000100000000;
			}
			if (bitStream.ReadMask())
			{
				val.centerOfMass = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000001000000000;
			}
			if (bitStream.ReadMask())
			{
				val.inertiaTensorRotation = (bitStream.ReadQuaternion(32)).ToUnityQuaternion();
				mask |= 0b00000000000000000000010000000000;
			}
			if (bitStream.ReadMask())
			{
				val.inertiaTensor = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000100000000000;
			}
			if (bitStream.ReadMask())
			{
				val.detectCollisions = bitStream.ReadBool();
				mask |= 0b00000000000000000001000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.position = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000010000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.rotation = (bitStream.ReadQuaternion(32)).ToUnityQuaternion();
				mask |= 0b00000000000000000100000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverIterations = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000000001000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.sleepThreshold = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000010000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.maxAngularVelocity = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000100000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverVelocityIterations = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000001000000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverIterationCount = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000010000000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverVelocityIterationCount = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000100000000000000000000;
			}
			return (val, mask, null);
		}

		public static (Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547, uint, uint?) DeserializeArchetypePuck_67d153e8cb5779a49a2e569ee35a4437_Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547_LOD0(InProtocolBitStream bitStream)
		{
			var mask = (uint)0;
			var val = new Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547();
			if (bitStream.ReadMask())
			{
				val.velocity = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000000000000001;
			}
			if (bitStream.ReadMask())
			{
				val.angularVelocity = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000000000000010;
			}
			if (bitStream.ReadMask())
			{
				val.drag = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000000000100;
			}
			if (bitStream.ReadMask())
			{
				val.angularDrag = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000000001000;
			}
			if (bitStream.ReadMask())
			{
				val.mass = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000000010000;
			}
			if (bitStream.ReadMask())
			{
				val.useGravity = bitStream.ReadBool();
				mask |= 0b00000000000000000000000000100000;
			}
			if (bitStream.ReadMask())
			{
				val.maxDepenetrationVelocity = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000000000000001000000;
			}
			if (bitStream.ReadMask())
			{
				val.isKinematic = bitStream.ReadBool();
				mask |= 0b00000000000000000000000010000000;
			}
			if (bitStream.ReadMask())
			{
				val.freezeRotation = bitStream.ReadBool();
				mask |= 0b00000000000000000000000100000000;
			}
			if (bitStream.ReadMask())
			{
				val.centerOfMass = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000001000000000;
			}
			if (bitStream.ReadMask())
			{
				val.inertiaTensorRotation = (bitStream.ReadQuaternion(32)).ToUnityQuaternion();
				mask |= 0b00000000000000000000010000000000;
			}
			if (bitStream.ReadMask())
			{
				val.inertiaTensor = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000000100000000000;
			}
			if (bitStream.ReadMask())
			{
				val.detectCollisions = bitStream.ReadBool();
				mask |= 0b00000000000000000001000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.position = (bitStream.ReadVector3(FloatMeta.NoCompression())).ToUnityVector3();
				mask |= 0b00000000000000000010000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.rotation = (bitStream.ReadQuaternion(32)).ToUnityQuaternion();
				mask |= 0b00000000000000000100000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverIterations = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000000001000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.sleepThreshold = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000010000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.maxAngularVelocity = bitStream.ReadFloat(FloatMeta.NoCompression());
				mask |= 0b00000000000000100000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverVelocityIterations = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000001000000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverIterationCount = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000010000000000000000000;
			}
			if (bitStream.ReadMask())
			{
				val.solverVelocityIterationCount = bitStream.ReadIntegerRange(32, -2147483648);
				mask |= 0b00000000000100000000000000000000;
			}

			return (val, mask, 0);
		}

		/// <summary>
		/// Resets byte array references to the local array instance that is kept in the lastSentData.
		/// If the array content has changed but remains of same length, the new content is copied into the local array instance.
		/// If the array length has changed, the array is cloned and overwrites the local instance.
		/// If the array has not changed, the reference is reset to the local array instance.
		/// Otherwise, changes to other fields on the component might cause the local array instance reference to become permanently lost.
		/// </summary>
		public void ResetByteArrays(ICoherenceComponentData lastSent, uint mask)
		{
			var last = lastSent as Puck_id2_UnityEngine__char_46_Rigidbody_2515451422962040547?;
		}
	}
}